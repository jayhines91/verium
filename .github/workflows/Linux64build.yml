name: Build Verium (Linux x86_64 • depends)

on:
  workflow_dispatch:
    inputs:
      target_ref:
        description: "Branch/Tag/SHA to build"
        required: true
        default: "Verium-1.3.5"
      depends_target:
        description: "Optional: build only this depends pkg first (e.g., boost, openssl). Leave empty for full depends."
        required: false
        default: ""
      verbose_make:
        description: "Verbose make output (V=1)"
        required: false
        default: "false"

concurrency:
  group: verium-linux
  cancel-in-progress: true

permissions:
  contents: write

defaults:
  run:
    shell: bash

env:
  HOST_TRIPLET: x86_64-pc-linux-gnu

jobs:
  linux64:
    runs-on: ubuntu-22.04

    steps:
      - name: Checkout target ref
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.target_ref }}
          submodules: recursive
          fetch-depth: 0

      - name: Base build deps (host)
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y \
            build-essential automake libtool pkg-config python3 \
            gcc-9 g++-9 \
            curl zip unzip ccache

          # Make gcc-9/g++-9 the system default for this job
          sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 100
          sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-9 100
          gcc --version; g++ --version

      - name: Cache compiled depends
        id: cache-depends
        uses: actions/cache@v4
        with:
          path: depends/built
          key: depends-${{ runner.os }}-${{ env.HOST_TRIPLET }}-gcc9-${{ hashFiles('depends/packages/*.mk') }}

      # ─────────────────────────────────────────────────────────────────────────
      # Boost 1.70 + glibc 2.34+ fix:
      # The classic failure is in boost/thread/pthread/thread_data.hpp at
      #   #if PTHREAD_STACK_MIN > 0
      # which breaks when PTHREAD_STACK_MIN is not a compile-time constant on newer glibc.
      # Patch turns this into a runtime check guarded by #ifdef, matching upstream fixes.
      # (Background: boostorg/thread issues show this exact problem and its fix.) :contentReference[oaicite:0]{index=0}
      # ─────────────────────────────────────────────────────────────────────────
      - name: Inject Boost pthread_stack_min fix (applied by depends)
        run: |
          set -euo pipefail
          mkdir -p depends/patches/boost
          cat > depends/patches/boost/pthread-stack-min-fix.patch <<'PATCH'
          diff --git a/boost/thread/pthread/thread_data.hpp b/boost/thread/pthread/thread_data.hpp
          index 3b7f4a1..0000000 100644
          --- a/boost/thread/pthread/thread_data.hpp
          +++ b/boost/thread/pthread/thread_data.hpp
          @@ -57,9 +57,17 @@ namespace boost
             std::size_t page_size = ::sysconf( _SC_PAGESIZE);
         #endif
-#if PTHREAD_STACK_MIN > 0
-            if (size<static_cast<std::size_t>(PTHREAD_STACK_MIN)) size=PTHREAD_STACK_MIN;
-#endif
+#ifdef PTHREAD_STACK_MIN
+            {
+              // On glibc 2.34+ PTHREAD_STACK_MIN may be a function-like sysconf value,
+              // not a preprocessor-time constant. Avoid #if on it; check at runtime.
+              std::size_t psm = static_cast<std::size_t>(PTHREAD_STACK_MIN);
+              if (psm > 0 && size < psm)
+                size = psm;
+            }
+#endif
             size = ((size+page_size-1)/page_size)*page_size;
             int res = pthread_attr_setstacksize(&val_, size);
             BOOST_VERIFY(!res && "pthread_attr_setstacksize failed");
PATCH

          # Append patch to boost.mk so depends applies it (bitcoin-style depends recognizes $(package)_patches)
          f=depends/packages/boost.mk
          if [ -f "$f" ] && ! grep -q 'pthread-stack-min-fix.patch' "$f"; then
            echo '' >> "$f"
            echo '$(package)_patches += pthread-stack-min-fix.patch' >> "$f"
            echo 'Injected pthread-stack-min-fix.patch into depends/packages/boost.mk'
          else
            echo "NOTE: $f not found or patch already listed; continuing."
          fi

      - name: Build depends (Linux)
        if: steps.cache-depends.outputs.cache-hit != 'true'
        run: |
          set -e
          export CC=gcc-9 CXX=g++-9
          if [ -n "${{ inputs.depends_target }}" ]; then
            echo "Priming depends target: ${{ inputs.depends_target }}"
            make -C depends HOST=${HOST_TRIPLET} CC_FOR_BUILD=gcc-9 CXX_FOR_BUILD=g++-9 \
              ${{ inputs.depends_target }} -j"$(nproc || echo 2)"
          fi

          make -C depends HOST=${HOST_TRIPLET} CC_FOR_BUILD=gcc-9 CXX_FOR_BUILD=g++-9 \
            -j"$(nproc || echo 2)" || {
              echo "---- tail any config.log ----"
              find depends/work/build -name config.log -exec sh -c 'echo "==> {}"; tail -n 120 "{}"' \;
              exit 1
            }

      - name: Configure (Linux)
        run: |
          set -e
          ./autogen.sh
          export CC=gcc-9 CXX=g++-9
          export CONFIG_SITE="$(pwd)/depends/${HOST_TRIPLET}/share/config.site"
          DEP="$(pwd)/depends/${HOST_TRIPLET}"

          ./configure \
            --host=${HOST_TRIPLET} \
            --prefix="$DEP" \
            --with-gui=qt5 \
            --with-qt-bindir="$DEP/native/bin" \
            --with-qt-incdir="$DEP/include" \
            --with-qt-libdir="$DEP/lib" \
            --disable-bench --disable-tests \
            --enable-reduce-exports \
            --disable-shared --enable-static

      - name: Build (Linux)
        run: |
          set -e
          if [ "${{ inputs.verbose_make }}" = "true" ]; then
            make -j"$(nproc || echo 2)" V=1
          else
            make -j"$(nproc || echo 2)"
          fi

      - name: Package + checksums (Linux)
        run: |
          set -euo pipefail
          V=$(git describe --tags --dirty --always || echo untagged)
          OUTDIR="out-linux"
          mkdir -p "$OUTDIR"

          # Collect typical outputs (daemon/CLI/qt). Adjust names if the repo differs.
          cp -f src/verium* "$OUTDIR/" 2>/dev/null || true
          cp -f src/qt/verium* "$OUTDIR/" 2>/dev/null || true

          # Make sure we actually have ELF binaries
          if [ -z "$(ls -A "$OUTDIR" 2>/dev/null)" ]; then
            echo "No Linux binaries found in $OUTDIR; exiting."
            exit 2
          fi

          PKG="verium-${V}-${HOST_TRIPLET}.tar.gz"
          tar -C "$OUTDIR" -czf "$PKG" .
          sha256sum "$PKG" > "${PKG}.SHA256SUMS"
          echo "ART_MAIN=$PKG" >> $GITHUB_ENV
          echo "ART_SUMS=${PKG}.SHA256SUMS" >> $GITHUB_ENV

      - name: Upload artifacts (binaries + checksums)
        uses: actions/upload-artifact@v4
        with:
          name: linux64-${{ env.HOST_TRIPLET }}
          path: |
            ${{ env.ART_MAIN }}
            ${{ env.ART_SUMS }}

      - name: Upload build logs (for debugging)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: linux-dep-logs
          path: |
            depends/work/build/**/config.log
            depends/work/build/**/config.status
          if-no-files-found: ignore
